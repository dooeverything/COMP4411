#include <assert.h>
#include "BezierCurveEvaluator.h"
using namespace std;
void BezierCurveEvaluator::evaluateCurve(const std::vector<Point>& ptvCtrlPts, 
										 std::vector<Point>& ptvEvaluatedCurvePts,
									   	 const float& fAniLength, const bool& bWrap) const
{
	ptvEvaluatedCurvePts.clear();
	int iCtrlPtCount = ptvCtrlPts.size();

	float x = 0.0;
	float y1;
	float y2;
	if (bWrap) {
		// if wrapping is on, interpolate the y value at xmin and
		// xmax so that the slopes of the lines adjacent to the
		// wraparound are equal.

		if ((ptvCtrlPts[0].x + fAniLength) - ptvCtrlPts[iCtrlPtCount - 1].x > 0.0f) {
			y2 = y1 = (ptvCtrlPts[0].y * (fAniLength - ptvCtrlPts[iCtrlPtCount - 1].x) +
				ptvCtrlPts[iCtrlPtCount - 1].y * ptvCtrlPts[0].x) /
				(ptvCtrlPts[0].x + fAniLength - ptvCtrlPts[iCtrlPtCount - 1].x);
		}
		else
			y2 = y1 = ptvCtrlPts[0].y;
	}
	else {
		// if wrapping is off, make the first and last segments of
		// the curve horizontal.

		y1 = ptvCtrlPts[0].y;
		y2 = ptvCtrlPts[iCtrlPtCount - 1].y;
	}

	ptvEvaluatedCurvePts.push_back(Point(0, y1));
	
	std::vector<Point>::const_iterator it;
	// Get 4 points, V_0, V_1, V_2, V_3 from ptvCtrlPts
	for (it = ptvCtrlPts.begin(); it != ptvCtrlPts.end()-1; it += 3) {

		if (it + 2 == ptvCtrlPts.end()) {
			break;
		}

		Point v0 = *it;
		Point v1 = *(it + 1);
		Point v2 = *(it + 2);
		//Point v3 = *(it + 3);
		Point v3;
		if (it + 3 == ptvCtrlPts.end()) {
			if (bWrap) {
				v3.x = fAniLength;
				v3.y = y2;
				displayBezierCurve(v0, v1, v2, v3, ptvEvaluatedCurvePts);
				return;
				//cout << v0 << v1 << v2 << v3 << endl;
				//cout << v3 << endl;
			}
			else {
				break;
			}
		}
		else {
			v3 = *(it + 3);
		}


		displayBezierCurve(v0, v1, v2, v3, ptvEvaluatedCurvePts);
		
		//cout << "\n" << endl;
	}

	for (; it != ptvCtrlPts.end(); it++) {
		ptvEvaluatedCurvePts.push_back(*it);
	}

	ptvEvaluatedCurvePts.push_back(Point(fAniLength, y2));
	cout << "Number of Points generated by Adaptive Bézier curve Algorithm: " << nPoints << endl;
}

bool BezierCurveEvaluator::flatEnough(Point v0, Point v1, Point v2, Point v3) const
{
	float d01 = v0.distance(v1);
	float d12 = v1.distance(v2); 
	float d23 = v2.distance(v3); 

	float d03 = v0.distance(v3);
 
	float d = (d01 + d12 + d23); 

	if (abs(d-d03) < 1e-5) {
		return true;
	}

	return false;
}

void BezierCurveEvaluator::displayBezierCurve(Point v0, Point v1, Point v2, Point v3, 
											  std::vector<Point>& ptvEvaluatedCurvePts) const
{
	if (flatEnough(v0, v1, v2, v3)) {
		ptvEvaluatedCurvePts.push_back(v0);
		ptvEvaluatedCurvePts.push_back(v3);
		return;
	}

	// Subdivide into Left and Right with u = 1/3
	float u = 0.333333;
	Point v0_1 = Point((1 - u) * v0.x + u * v1.x, (1 - u) * v0.y + u * v1.y);
	Point v1_1 = Point((1 - u) * v1.x + u * v2.x, (1 - u) * v1.y + u * v2.y);
	Point v2_1 = Point((1 - u) * v2.x + u * v3.x, (1 - u) * v2.y + u * v3.y);

	Point v0_2 = Point((1 - u) * v0_1.x + u * v1_1.x, (1 - u) * v0_1.y + u * v1_1.y);
	Point v1_2 = Point((1 - u) * v1_1.x + u * v2_1.x, (1 - u) * v1_1.y + u * v2_1.y);

	Point q = Point((1 - u) * v0_2.x + u * v1_2.x, (1 - u) * v0_2.y + u * v1_2.y);

	// Leftside
	displayBezierCurve(v0, v0_1, v0_2, q, ptvEvaluatedCurvePts);

	// Rightside
	displayBezierCurve(q, v1_2, v2_1, v3, ptvEvaluatedCurvePts);

	return;
}
